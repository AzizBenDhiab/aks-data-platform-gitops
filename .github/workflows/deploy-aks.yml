# # .github/workflows/deploy-aks-data-platform.yml
# name: Deploy AKS Data Platform with ArgoCD
# on:
#   # push:
#   #   branches: [main]
#   #   paths:
#   #     - "terraform/**"
#   #     - "k8s/**"
#   #     - "argocd/**"
#   #     - ".github/workflows/**"
#   #     - "manifests/**"
#   #     - "values/**"
#   pull_request:
#     branches: [main]
#   workflow_dispatch:
#     inputs:
#       environment:
#         description: "Environment to deploy"
#         required: true
#         default: "dev"
#         type: choice
#         options:
#           - dev
#           - staging
#           - prod
#       resource_group_name:
#         description: "Resource Group Name"
#         required: true
#         default: "rg-aks-data-dev"
#         type: string
#       location:
#         description: "Azure Region"
#         required: true
#         default: "West Europe"
#         type: string
#       cluster_name:
#         description: "AKS Cluster Name"
#         required: true
#         default: "aks-data-dev-test"
#         type: string
#       kubernetes_version:
#         description: "Kubernetes Version"
#         required: true
#         default: "1.32.5"
#         type: string
#       system_node_count:
#         description: "System Node Count"
#         required: true
#         default: "2"
#         type: string
#       subscription_id:
#         description: "Azure Subscription ID"
#         required: true
#         default: "a6de3cd4-15d9-4c7f-87ac-9a4399b01e45"
#         type: string
#       workload_identity_namespace:
#         description: "Workload Identity Namespace"
#         required: true
#         default: "default"
#         type: string
#       workload_identity_service_account:
#         description: "Workload Identity Service Account"
#         required: true
#         default: "workload-identity-sa"
#         type: string
#       keyvaultname:
#         description: "Key Vault Name"
#         required: true
#         default: "kv-aks-data-dev-95548452"
#         type: string
#       destroy:
#         description: "Destroy infrastructure"
#         required: false
#         default: false
#         type: boolean

# env:
#   ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
#   ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
#   ARM_SUBSCRIPTION_ID: ${{ github.event.inputs.subscription_id || secrets.AZURE_SUBSCRIPTION_ID }}
#   ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
#   TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
#   TF_VAR_resource_group_name: ${{ github.event.inputs.resource_group_name || 'rg-aks-data-dev' }}
#   TF_VAR_location: ${{ github.event.inputs.location || 'West Europe' }}
#   TF_VAR_cluster_name: ${{ github.event.inputs.cluster_name || 'aks-data-dev-test' }}
#   TF_VAR_kubernetes_version: ${{ github.event.inputs.kubernetes_version || '1.32.5' }}
#   TF_VAR_system_node_count: ${{ github.event.inputs.system_node_count || '2' }}
#   TF_VAR_subscription_id: ${{ github.event.inputs.subscription_id || 'a6de3cd4-15d9-4c7f-87ac-9a4399b01e45' }}
#   TF_VAR_workload_identity_namespace: ${{ github.event.inputs.workload_identity_namespace || 'default' }}
#   TF_VAR_workload_identity_service_account: ${{ github.event.inputs.workload_identity_service_account || 'workload-identity-sa' }}
#   TF_VAR_keyvaultname: ${{ github.event.inputs.keyvaultname || 'kv-aks-data-dev-95548452' }}

# jobs:
#   terraform-plan:
#     name: "Terraform Plan"
#     runs-on: ubuntu-latest
#     environment: ${{ github.event.inputs.environment || 'dev' }}

#     outputs:
#       tfplanExitCode: ${{ steps.tf-plan.outputs.exitcode }}

#     steps:
#       - name: Checkout
#         uses: actions/checkout@v4

#       - name: Setup Terraform
#         uses: hashicorp/setup-terraform@v3
#         with:
#           terraform_version: 1.5.0
#           terraform_wrapper: false

#       - name: Azure Login
#         uses: azure/login@v1
#         with:
#           creds: ${{ secrets.AZURE_CREDENTIALS }}

#       - name: Terraform Init
#         working-directory: ./terraform
#         run: |
#           terraform init \
#             -backend-config="resource_group_name=${{ secrets.TF_STATE_RG }}" \
#             -backend-config="storage_account_name=${{ secrets.TF_STATE_SA }}" \
#             -backend-config="container_name=tfstate" \
#             -backend-config="key=${{ env.TF_VAR_environment }}.terraform.tfstate"

#       - name: Terraform Validate
#         working-directory: ./terraform
#         run: terraform validate

#       - name: Terraform Plan
#         id: tf-plan
#         working-directory: ./terraform
#         run: |
#           export exitcode=0
#           terraform plan -detailed-exitcode -no-color -out tfplan || export exitcode=$?

#           echo "exitcode=$exitcode" >> $GITHUB_OUTPUT

#           if [ $exitcode -eq 1 ]; then
#             echo Terraform Plan Failed!
#             exit 1
#           else 
#             exit 0
#           fi

#       - name: Publish Terraform Plan
#         uses: actions/upload-artifact@v3
#         with:
#           name: tfplan-${{ env.TF_VAR_environment }}
#           path: ./terraform/tfplan

#   terraform-apply:
#     name: "Terraform Apply"
#     if: github.ref == 'refs/heads/main' && needs.terraform-plan.outputs.tfplanExitCode == 2
#     runs-on: ubuntu-latest
#     environment: ${{ github.event.inputs.environment || 'dev' }}
#     needs: [terraform-plan]

#     outputs:
#       cluster_name: ${{ steps.tf-output.outputs.cluster_name }}
#       resource_group: ${{ steps.tf-output.outputs.resource_group }}
#       keyvault_name: ${{ steps.tf-output.outputs.keyvault_name }}
#       azure_client_id: ${{ steps.tf-output.outputs.azure_client_id }}
#       azure_tenant_id: ${{ steps.tf-output.outputs.azure_tenant_id }}

#     steps:
#       - name: Checkout
#         uses: actions/checkout@v4

#       - name: Setup Terraform
#         uses: hashicorp/setup-terraform@v3
#         with:
#           terraform_version: 1.5.0
#           terraform_wrapper: false

#       - name: Azure Login
#         uses: azure/login@v1
#         with:
#           creds: ${{ secrets.AZURE_CREDENTIALS }}

#       - name: Terraform Init
#         working-directory: ./terraform
#         run: |
#           terraform init \
#             -backend-config="resource_group_name=${{ secrets.TF_STATE_RG }}" \
#             -backend-config="storage_account_name=${{ secrets.TF_STATE_SA }}" \
#             -backend-config="container_name=tfstate" \
#             -backend-config="key=${{ env.TF_VAR_environment }}.terraform.tfstate"

#       - name: Download Terraform Plan
#         uses: actions/download-artifact@v3
#         with:
#           name: tfplan-${{ env.TF_VAR_environment }}
#           path: ./terraform

#       - name: Terraform Apply
#         working-directory: ./terraform
#         run: terraform apply -auto-approve tfplan

#       - name: Get Terraform Outputs
#         id: tf-output
#         working-directory: ./terraform
#         run: |
#           echo "cluster_name=$(terraform output -raw cluster_name)" >> $GITHUB_OUTPUT
#           echo "resource_group=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
#           echo "keyvault_name=$(terraform output -raw keyvault_name)" >> $GITHUB_OUTPUT
#           echo "azure_client_id=$(terraform output -raw azure_client_id)" >> $GITHUB_OUTPUT
#           echo "azure_tenant_id=$(terraform output -raw azure_tenant_id)" >> $GITHUB_OUTPUT

#   generate-keyvault-secrets:
#     name: "Generate Key Vault Secrets"
#     runs-on: ubuntu-latest
#     needs: [terraform-apply]
#     if: success()

#     steps:
#       - name: Checkout
#         uses: actions/checkout@v4

#       - name: Azure Login
#         uses: azure/login@v1
#         with:
#           creds: ${{ secrets.AZURE_CREDENTIALS }}

#       - name: Generate and Store Secrets in Key Vault
#         run: |
#           # Get Key Vault name from terraform output
#           KEYVAULT_NAME="${{ needs.terraform-apply.outputs.keyvault_name }}"

#           echo "Using Key Vault: $KEYVAULT_NAME"

#           # Generate secure passwords for all applications
#           SUPERSET_SECRET_KEY=$(openssl rand -base64 48 | tr -d "=+/" | cut -c1-48)
#           SUPERSET_POSTGRES_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
#           SUPERSET_ADMIN_PASSWORD=$(openssl rand -base64 16 | tr -d "=+/" | cut -c1-16)
#           NIFI_SENSITIVE_KEY=$(openssl rand -base64 24 | tr -d "=+/" | cut -c1-24)
#           NIFI_KEYSTORE_PASSWORD=$(openssl rand -base64 24 | tr -d "=+/" | cut -c1-24)
#           NIFI_TRUSTSTORE_PASSWORD=$(openssl rand -base64 24 | tr -d "=+/" | cut -c1-24)
#           NIFI_ADMIN_PASSWORD=$(openssl rand -base64 16 | tr -d "=+/" | cut -c1-16)
#           KOBO_REDIS_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
#           KOBO_ADMIN_PASSWORD=$(openssl rand -base64 16 | tr -d "=+/" | cut -c1-16)
#           KOBO_DJANGO_SECRET=$(openssl rand -base64 48 | tr -d "=+/" | cut -c1-48)
#           KOBO_POSTGRES_ADMIN_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
#           KOBO_POSTGRES_USER_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
#           KOBO_MONGO_ROOT_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
#           KOBO_MONGO_USER_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)

#           # Add Superset secrets
#           echo "Adding Superset secrets..."
#           az keyvault secret set --vault-name $KEYVAULT_NAME --name "superset-secret-key" --value "$SUPERSET_SECRET_KEY"
#           az keyvault secret set --vault-name $KEYVAULT_NAME --name "superset-postgres-password" --value "$SUPERSET_POSTGRES_PASSWORD"
#           az keyvault secret set --vault-name $KEYVAULT_NAME --name "superset-admin-password" --value "$SUPERSET_ADMIN_PASSWORD"

#           # Add NiFi secrets
#           echo "Adding NiFi secrets..."
#           az keyvault secret set --vault-name $KEYVAULT_NAME --name "nifi-sensitive-key" --value "$NIFI_SENSITIVE_KEY"
#           az keyvault secret set --vault-name $KEYVAULT_NAME --name "nifi-keystore-password" --value "$NIFI_KEYSTORE_PASSWORD"
#           az keyvault secret set --vault-name $KEYVAULT_NAME --name "nifi-truststore-password" --value "$NIFI_TRUSTSTORE_PASSWORD"
#           az keyvault secret set --vault-name $KEYVAULT_NAME --name "nifi-admin-password" --value "$NIFI_ADMIN_PASSWORD"

#           # Add KoboToolbox secrets
#           echo "Adding KoboToolbox secrets..."
#           az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-redis-password" --value "$KOBO_REDIS_PASSWORD"
#           az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-admin-password" --value "$KOBO_ADMIN_PASSWORD"
#           az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-django-secret" --value "$KOBO_DJANGO_SECRET"
#           az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-postgres-admin-password" --value "$KOBO_POSTGRES_ADMIN_PASSWORD"
#           az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-postgres-user-password" --value "$KOBO_POSTGRES_USER_PASSWORD"
#           az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-mongo-root-password" --value "$KOBO_MONGO_ROOT_PASSWORD"
#           az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-mongo-user-password" --value "$KOBO_MONGO_USER_PASSWORD"

#           echo "All secrets have been stored in Key Vault: $KEYVAULT_NAME"

#   update-repository-placeholders:
#     name: "Update Repository Placeholders"
#     runs-on: ubuntu-latest
#     needs: [terraform-apply, generate-keyvault-secrets]
#     if: success()

#     steps:
#       - name: Checkout
#         uses: actions/checkout@v4
#         with:
#           token: ${{ secrets.GITHUB_TOKEN }}

#       - name: Update Placeholders in Repository Files
#         run: |
#           # Get values from terraform outputs
#           KEYVAULT_NAME="${{ needs.terraform-apply.outputs.keyvault_name }}"
#           AZURE_CLIENT_ID="${{ needs.terraform-apply.outputs.azure_client_id }}"
#           AZURE_TENANT_ID="${{ needs.terraform-apply.outputs.azure_tenant_id }}"

#           echo "Updating placeholders with:"
#           echo "KEYVAULT_NAME: $KEYVAULT_NAME"
#           echo "AZURE_CLIENT_ID: $AZURE_CLIENT_ID"
#           echo "AZURE_TENANT_ID: $AZURE_TENANT_ID"

#           # Find and replace placeholders in all files
#           find . -type f \( -name "*.yaml" -o -name "*.yml" -o -name "*.json" -o -name "*.sh" \) -not -path "./.git/*" -exec grep -l "__AZURE_KEYVAULT_NAME__\|__AZURE_CLIENT_ID__\|__AZURE_TENANT_ID__" {} \; | while read file; do
#             echo "Updating file: $file"
#             sed -i "s/__AZURE_KEYVAULT_NAME__/$KEYVAULT_NAME/g" "$file"
#             sed -i "s/__AZURE_CLIENT_ID__/$AZURE_CLIENT_ID/g" "$file"
#             sed -i "s/__AZURE_TENANT_ID__/$AZURE_TENANT_ID/g" "$file"
#           done

#       - name: Commit and Push Changes
#         run: |
#           git config --local user.email "action@github.com"
#           git config --local user.name "GitHub Action"
#           git add .
#           if git diff --staged --quiet; then
#             echo "No changes to commit"
#           else
#             git commit -m "Update Azure placeholders with deployment values"
#             git push
#           fi

#   setup-argocd:
#     name: "Setup ArgoCD"
#     runs-on: ubuntu-latest
#     needs: [terraform-apply, update-repository-placeholders]
#     if: success()

#     steps:
#       - name: Checkout
#         uses: actions/checkout@v4
#         with:
#           ref: main # Use updated main branch with placeholders replaced

#       - name: Azure Login
#         uses: azure/login@v1
#         with:
#           creds: ${{ secrets.AZURE_CREDENTIALS }}

#       - name: Get AKS Credentials
#         run: |
#           az aks get-credentials \
#             --resource-group ${{ needs.terraform-apply.outputs.resource_group }} \
#             --name ${{ needs.terraform-apply.outputs.cluster_name }} \
#             --overwrite-existing

#       - name: Install ArgoCD
#         run: |
#           # Create ArgoCD namespace
#           kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -

#           # Install ArgoCD
#           kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

#           # Wait for ArgoCD to be ready
#           kubectl wait --for=condition=available --timeout=600s deployment/argocd-server -n argocd

#       - name: Configure ArgoCD
#         run: |
#           # Get ArgoCD admin password
#           ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
#           echo "ARGOCD_PASSWORD=$ARGOCD_PASSWORD" >> $GITHUB_ENV

#           # Create ArgoCD service LoadBalancer
#           kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'

#           # Wait for external IP (with timeout)
#           timeout 300 bash -c 'until kubectl get svc argocd-server -n argocd -o jsonpath="{.status.loadBalancer.ingress[0].ip}" | grep -E "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$"; do sleep 10; done'

#       - name: Deploy Root Application via ArgoCD
#         run: |
#           # Get ArgoCD server external IP
#           ARGOCD_SERVER=$(kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
#           echo "ArgoCD Server IP: $ARGOCD_SERVER"

#           # Install ArgoCD CLI
#           curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
#           chmod +x argocd
#           sudo mv argocd /usr/local/bin/

#           # Wait for ArgoCD API to be ready
#           sleep 30

#           # Login to ArgoCD
#           argocd login $ARGOCD_SERVER --username admin --password $ARGOCD_PASSWORD --insecure

#           # Apply the root application directly via kubectl (more reliable)
#           kubectl apply -f - <<EOF
#           apiVersion: argoproj.io/v1alpha1
#           kind: Application
#           metadata:
#             name: root-app
#             namespace: argocd
#           spec:
#             project: default
#             source:
#               repoURL: https://github.com/${{ github.repository }}
#               targetRevision: HEAD
#               path: argocd/apps
#             destination:
#               server: https://kubernetes.default.svc
#               namespace: argocd
#             syncPolicy:
#               automated:
#                 prune: true
#                 selfHeal: true
#           EOF

#           # Wait for application to be created
#           sleep 10

#           # Sync root application
#           argocd app sync root-app --timeout 300

#           echo "ArgoCD setup complete!"
#           echo "Access ArgoCD at: http://$ARGOCD_SERVER"
#           echo "Username: admin"
#           echo "Password: $ARGOCD_PASSWORD"

#   terraform-destroy:
#     name: "Terraform Destroy"
#     if: github.event.inputs.destroy == 'true'
#     runs-on: ubuntu-latest
#     environment: ${{ github.event.inputs.environment || 'dev' }}

#     steps:
#       - name: Checkout
#         uses: actions/checkout@v4

#       - name: Setup Terraform
#         uses: hashicorp/setup-terraform@v3
#         with:
#           terraform_version: 1.5.0

#       - name: Azure Login
#         uses: azure/login@v1
#         with:
#           creds: ${{ secrets.AZURE_CREDENTIALS }}

#       - name: Terraform Init
#         working-directory: ./terraform
#         run: |
#           terraform init \
#             -backend-config="resource_group_name=${{ secrets.TF_STATE_RG }}" \
#             -backend-config="storage_account_name=${{ secrets.TF_STATE_SA }}" \
#             -backend-config="container_name=tfstate" \
#             -backend-config="key=${{ env.TF_VAR_environment }}.terraform.tfstate"

#       - name: Terraform Destroy
#         working-directory: ./terraform
#         run: terraform destroy -auto-approve
