# .github/workflows/deploy-aks-data-platform.yml
name: Deploy AKS Data Platform with ArgoCD
on:
  # push:
  #   branches: [main]
  #   paths:
  #     - "terraform/**"
  #     - "k8s/**"
  #     - "argocd/**"
  #     - ".github/workflows/**"
  #     - "manifests/**"
  #     - "values/**"
  # pull_request:
  #   branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - staging
          - prod
      resource_group_name:
        description: "Resource Group Name"
        required: true
        default: "rg-aks-data-dev"
        type: string
      location:
        description: "Azure Region"
        required: true
        default: "West Europe"
        type: string
      cluster_name:
        description: "AKS Cluster Name"
        required: true
        default: "aks-data-dev-test"
        type: string
      kubernetes_version:
        description: "Kubernetes Version"
        required: true
        default: "1.32.5"
        type: string
      system_node_count:
        description: "System Node Count"
        required: true
        default: "2"
        type: string
      workload_identity_namespace:
        description: "Workload Identity Namespace"
        required: true
        default: "default"
        type: string
      workload_identity_service_account:
        description: "Workload Identity Service Account"
        required: true
        default: "workload-identity-sa"
        type: string
      keyvaultname:
        description: "Key Vault Name"
        required: true
        default: "kv-aks-data-dev-95548452"
        type: string
      destroy:
        description: "Destroy infrastructure"
        required: false
        default: false
        type: boolean

# Grant GITHUB_TOKEN write permissions for id-token and contents
permissions:
  id-token: write
  contents: read
  pull-requests: write

env:
  # Remove ARM_CLIENT_SECRET - not needed for OIDC
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  ARM_USE_OIDC: true
  TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
  TF_VAR_resource_group_name: ${{ github.event.inputs.resource_group_name || 'rg-aks-data-dev' }}
  TF_VAR_location: ${{ github.event.inputs.location || 'West Europe' }}
  TF_VAR_cluster_name: ${{ github.event.inputs.cluster_name || 'aks-data-dev-test' }}
  TF_VAR_kubernetes_version: ${{ github.event.inputs.kubernetes_version || '1.32.5' }}
  TF_VAR_system_node_count: ${{ github.event.inputs.system_node_count || '2' }}
  TF_VAR_subscription_id: ${{ github.event.inputs.subscription_id || 'a6de3cd4-15d9-4c7f-87ac-9a4399b01e45' }}
  TF_VAR_workload_identity_namespace: ${{ github.event.inputs.workload_identity_namespace || 'default' }}
  TF_VAR_workload_identity_service_account: ${{ github.event.inputs.workload_identity_service_account || 'workload-identity-sa' }}
  TF_VAR_keyvaultname: ${{ github.event.inputs.keyvaultname || 'kv-aks-data-dev-95548452' }}

jobs:
  terraform:
    name: "Terraform Plan & Apply"
    runs-on: ubuntu-latest

    outputs:
      cluster_name: ${{ steps.tf-output.outputs.cluster_name }}
      resource_group: ${{ steps.tf-output.outputs.resource_group }}
      keyvault_name: ${{ steps.tf-output.outputs.keyvault_name }}
      azure_client_id: ${{ steps.tf-output.outputs.azure_client_id }}
      azure_tenant_id: ${{ steps.tf-output.outputs.azure_tenant_id }}
      user_assigned_identity_client_id: ${{ steps.tf-output.outputs.user_assigned_identity_client_id }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Init
        working-directory: ./terraform
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ secrets.TF_STATE_RG }}" \
            -backend-config="storage_account_name=${{ secrets.TF_STATE_SA }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=${{ env.TF_VAR_environment }}.terraform.tfstate"

      - name: Terraform Validate
        working-directory: ./terraform
        run: terraform validate

      - name: Terraform Plan
        working-directory: ./terraform
        run: |
          terraform plan -out=tfplan-${{ env.TF_VAR_cluster_name }}
          echo "Plan file created: tfplan-${{ env.TF_VAR_cluster_name }}"

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main'
        working-directory: ./terraform
        run: |
          echo "Applying terraform plan..."
          ls -la tfplan  # Verify plan file exists
          terraform apply -auto-approve tfplan-${{ env.TF_VAR_cluster_name }}

      - name: Get Terraform Outputs
        if: github.ref == 'refs/heads/main'
        id: tf-output
        working-directory: ./terraform
        run: |
          echo "=== Terraform Outputs Raw Values ==="
          terraform output azure_tenant_id
          terraform output user_assigned_identity_client_id
          echo "=== End Raw Values ==="
          
          echo "cluster_name=$(terraform output -raw cluster_name)" >> $GITHUB_OUTPUT
          echo "resource_group=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
          echo "keyvault_name=$(terraform output -raw keyvault_name)" >> $GITHUB_OUTPUT
          echo "azure_client_id=$(terraform output -raw azure_client_id)" >> $GITHUB_OUTPUT
          echo "azure_tenant_id=$(terraform output -raw azure_tenant_id)" >> $GITHUB_OUTPUT
          echo "user_assigned_identity_client_id=$(terraform output -raw user_assigned_identity_client_id)" >> $GITHUB_OUTPUT

  generate-keyvault-secrets:
    name: "Generate Key Vault Secrets"
    runs-on: ubuntu-latest
    needs: [terraform]
    if: success()

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Generate and Store Secrets in Key Vault
        run: |
          # Get Key Vault name from terraform output
          KEYVAULT_NAME="${{ needs.terraform.outputs.keyvault_name }}"

          echo "Using Key Vault: $KEYVAULT_NAME"

          # Generate secure passwords for all applications
          SUPERSET_SECRET_KEY=$(openssl rand -base64 48 | tr -d "=+/" | cut -c1-48)
          SUPERSET_POSTGRES_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          SUPERSET_ADMIN_PASSWORD=$(openssl rand -base64 16 | tr -d "=+/" | cut -c1-16)
          NIFI_SENSITIVE_KEY=$(openssl rand -base64 24 | tr -d "=+/" | cut -c1-24)
          NIFI_KEYSTORE_PASSWORD=$(openssl rand -base64 24 | tr -d "=+/" | cut -c1-24)
          NIFI_TRUSTSTORE_PASSWORD=$(openssl rand -base64 24 | tr -d "=+/" | cut -c1-24)
          NIFI_ADMIN_PASSWORD=$(openssl rand -base64 16 | tr -d "=+/" | cut -c1-16)
          KOBO_REDIS_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          KOBO_ADMIN_PASSWORD=$(openssl rand -base64 16 | tr -d "=+/" | cut -c1-16)
          KOBO_DJANGO_SECRET=$(openssl rand -base64 48 | tr -d "=+/" | cut -c1-48)
          KOBO_POSTGRES_ADMIN_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          KOBO_POSTGRES_USER_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          KOBO_MONGO_ROOT_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          KOBO_MONGO_USER_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          GRAFANA_ADMIN_PASSWORD=$(openssl rand -base64 16 | tr -d "=+/" | cut -c1-16)
          ALERTMANAGER_SECRET=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          PROMETHEUS_SECRET=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)

          # Add monitoring secrets to Key Vault
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "grafana-admin-user" --value "admin"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "grafana-admin-password" --value "$GRAFANA_ADMIN_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "alertmanager-secret" --value "$ALERTMANAGER_SECRET"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "prometheus-secret" --value "$PROMETHEUS_SECRET"

          # Add Joget secrets to Key Vault
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "joget-database" --value "joget"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "joget-username" --value "joget_user"
          # Add Superset secrets
          echo "Adding Superset secrets..."
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "superset-secret-key" --value "$SUPERSET_SECRET_KEY"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "superset-postgres-password" --value "$SUPERSET_POSTGRES_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "superset-admin-password" --value "$SUPERSET_ADMIN_PASSWORD"

          # Add NiFi secrets
          echo "Adding NiFi secrets..."
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "nifi-sensitive-key" --value "$NIFI_SENSITIVE_KEY"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "nifi-keystore-password" --value "$NIFI_KEYSTORE_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "nifi-truststore-password" --value "$NIFI_TRUSTSTORE_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "nifi-admin-password" --value "$NIFI_ADMIN_PASSWORD"

          # Add KoboToolbox secrets
          echo "Adding KoboToolbox secrets..."
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-redis-password" --value "$KOBO_REDIS_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-admin-password" --value "$KOBO_ADMIN_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-django-secret" --value "$KOBO_DJANGO_SECRET"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-postgres-admin-password" --value "$KOBO_POSTGRES_ADMIN_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-postgres-user-password" --value "$KOBO_POSTGRES_USER_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-mongo-root-password" --value "$KOBO_MONGO_ROOT_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-mongo-user-password" --value "$KOBO_MONGO_USER_PASSWORD"

          echo "All secrets have been stored in Key Vault: $KEYVAULT_NAME"

  setup-argocd:
    name: "Setup ArgoCD"
    runs-on: ubuntu-latest
    needs: [terraform, generate-keyvault-secrets]
    if: success()

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.terraform.outputs.resource_group }} \
            --name ${{ needs.terraform.outputs.cluster_name }} \
            --overwrite-existing

      - name: Install ArgoCD
        run: |
          # Create ArgoCD namespace
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -

          # Install ArgoCD
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

          # Wait for ArgoCD to be ready
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-server -n argocd

          # Debug: Check ArgoCD installation
          echo "=== ArgoCD Installation Debug ==="
          kubectl get pods -n argocd
          kubectl get configmaps -n argocd
          echo "=== End Debug ==="

      - name: Configure ArgoCD
        run: |
          # Get ArgoCD admin password
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "ARGOCD_PASSWORD=$ARGOCD_PASSWORD" >> $GITHUB_ENV

          # Create ArgoCD service LoadBalancer
          kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'

          # Get Azure parameters from terraform outputs for environment variable substitution
          AZURE_CLIENT_ID="${{ needs.terraform.outputs.user_assigned_identity_client_id }}"
          AZURE_TENANT_ID="${{ needs.terraform.outputs.azure_tenant_id }}"
          KEYVAULT_NAME="${{ needs.terraform.outputs.keyvault_name }}"

          # Fallback for tenant ID if terraform output is empty
          if [ -z "$AZURE_TENANT_ID" ]; then
            echo "Terraform azure_tenant_id is empty, using Azure CLI to get tenant ID..."
            AZURE_TENANT_ID=$(az account show --query tenantId -o tsv)
            echo "Using tenant ID from Azure CLI: $AZURE_TENANT_ID"
          fi

          # Debug: Print the values we're getting from terraform
          echo "=== Terraform Outputs Debug ==="
          echo "AZURE_CLIENT_ID (user_assigned_identity): '$AZURE_CLIENT_ID'"
          echo "AZURE_TENANT_ID: '$AZURE_TENANT_ID'" 
          echo "KEYVAULT_NAME: '$KEYVAULT_NAME'"
          echo "Also available azure_client_id: '${{ needs.terraform.outputs.azure_client_id }}'"
          echo "=== End Debug ==="

          # # Create a ConfigMap with Azure environment variables for ArgoCD to use
          # kubectl create configmap argocd-env -n argocd \
          #   --from-literal=AZURE_CLIENT_ID="$AZURE_CLIENT_ID" \
          #   --from-literal=AZURE_TENANT_ID="$AZURE_TENANT_ID" \
          #   --from-literal=KEYVAULT_NAME="$KEYVAULT_NAME" \
          #   --dry-run=client -o yaml | kubectl apply -f -

          # # Configure improved CMP plugin for envsubst with better error handling
          # cat <<EOF | kubectl apply -f -
          # apiVersion: v1
          # kind: ConfigMap
          # metadata:
          #   name: cmp-plugin
          #   namespace: argocd
          #   labels:
          #     app.kubernetes.io/part-of: argocd
          # data:
          #   plugin.yaml: |
          #     apiVersion: argoproj.io/v1alpha1
          #     kind: ConfigManagementPlugin
          #     metadata:
          #       name: envsubst
          #     spec:
          #       version: v1.0
          #       init:
          #         command: ["sh", "-c"]
          #         args:
          #           - |
          #             set -e
          #             echo "CMP envsubst: Processing environment variable substitution..."
          #             # Verify required environment variables are present
          #             if [ -z "\$AZURE_CLIENT_ID" ] || [ -z "\$AZURE_TENANT_ID" ] || [ -z "\$KEYVAULT_NAME" ]; then
          #               echo "WARNING: Some required environment variables are missing"
          #               echo "AZURE_CLIENT_ID: \${AZURE_CLIENT_ID:-NOT_SET}"
          #               echo "AZURE_TENANT_ID: \${AZURE_TENANT_ID:-NOT_SET}" 
          #               echo "KEYVAULT_NAME: \${KEYVAULT_NAME:-NOT_SET}"
          #             fi
          #       generate:
          #         command: ["sh", "-c"]
          #         args:
          #           - |
          #             set -e
          #             echo "CMP envsubst: Generating manifests with environment variable substitution..."
          #             find \$ARGOCD_APP_SOURCE_PATH -name '*.yaml' -o -name '*.yml' | while read -r file; do
          #               echo "Processing: \$file"
          #               envsubst < "\$file"
          #               echo "---"
          #             done
          #       discover:
          #         fileName: "*.yaml"
          #       allowConcurrency: true
          # EOF

          # # Skip legacy ConfigMap patching - using modern CMP sidecar approach
          # echo "Using modern CMP sidecar approach, skipping legacy ConfigMap plugin configuration..."
          
          # # Verify ConfigMap content (should not have configManagementPlugins section)
          # echo "=== ConfigMap Content (should not contain configManagementPlugins) ==="
          # kubectl get configmap argocd-cm -n argocd -o yaml
          # echo "=== End ConfigMap Content ==="

          # # Inject environment variables into ArgoCD repo-server
          # kubectl set env deployment/argocd-repo-server -n argocd --from=configmap/argocd-env

          # # Add CMP sidecar container to repo-server instead of patching existing container
          # kubectl patch deployment argocd-repo-server -n argocd --type=json -p='[
          #   {
          #     "op": "add",
          #     "path": "/spec/template/spec/containers/-",
          #     "value": {
          #       "name": "cmp-envsubst",
          #       "command": ["/var/run/argocd/argocd-cmp-server"],
          #       "image": "quay.io/argoproj/argocd:v2.12.4",
          #       "securityContext": {
          #         "runAsNonRoot": true,
          #         "runAsUser": 999
          #       },
          #       "env": [
          #         {
          #           "name": "AZURE_CLIENT_ID",
          #           "valueFrom": {
          #             "configMapKeyRef": {
          #               "name": "argocd-env",
          #               "key": "AZURE_CLIENT_ID"
          #             }
          #           }
          #         },
          #         {
          #           "name": "AZURE_TENANT_ID",
          #           "valueFrom": {
          #             "configMapKeyRef": {
          #               "name": "argocd-env",
          #               "key": "AZURE_TENANT_ID"
          #             }
          #           }
          #         },
          #         {
          #           "name": "KEYVAULT_NAME",
          #           "valueFrom": {
          #             "configMapKeyRef": {
          #               "name": "argocd-env",
          #               "key": "KEYVAULT_NAME"
          #             }
          #           }
          #         }
          #       ],
          #       "volumeMounts": [
          #         {
          #           "mountPath": "/var/run/argocd",
          #           "name": "var-files"
          #         },
          #         {
          #           "mountPath": "/home/argocd/cmp-server/config",
          #           "name": "cmp-envsubst-plugin"
          #         },
          #         {
          #           "mountPath": "/home/argocd/cmp-server/plugins",
          #           "name": "cmp-plugins"
          #         },
          #         {
          #           "mountPath": "/tmp",
          #           "name": "cmp-tmp"
          #         }
          #       ]
          #     }
          #   },
          #   {
          #     "op": "add",
          #     "path": "/spec/template/spec/volumes/-",
          #     "value": {
          #       "name": "cmp-tmp",
          #       "emptyDir": {}
          #     }
          #   },
          #   {
          #     "op": "add",
          #     "path": "/spec/template/spec/volumes/-",
          #     "value": {
          #       "name": "cmp-plugins",
          #       "emptyDir": {}
          #     }
          #   },
          #   {
          #     "op": "add",
          #     "path": "/spec/template/spec/volumes/-",
          #     "value": {
          #       "configMap": {
          #         "name": "cmp-plugin"
          #       },
          #       "name": "cmp-envsubst-plugin"
          #     }
          #   }
          # ]'

          # # Skip envsubst installation here - will do it after restart with proper pod targeting
          # echo "Skipping initial envsubst installation - will install after pod restart..."

          # # Force restart of repo-server to ensure environment variables and plugin are loaded
          # kubectl rollout restart deployment/argocd-repo-server -n argocd

          # # Wait for repo-server deployment to be ready
          # kubectl rollout status deployment/argocd-repo-server -n argocd --timeout=300s
          
          # # Wait additional time for containers to be fully ready
          # echo "Waiting for containers to stabilize..."
          # sleep 30
          
          # # Check pod and container status before executing commands
          # echo "=== Repo Server Pod Status ==="
          # kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-repo-server
          # REPO_POD=$(kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-repo-server -o jsonpath='{.items[0].metadata.name}')
          # echo "Using pod: $REPO_POD"
          # kubectl get pod $REPO_POD -n argocd -o jsonpath='{.status.containerStatuses[*].name}' | tr ' ' '\n' | nl
          # echo "=== End Pod Status ==="

          # # Verify environment variables are properly injected
          # echo "Verifying environment variables in repo-server..."
          # kubectl exec -n argocd $REPO_POD -c argocd-repo-server -- env | grep -E "AZURE_CLIENT_ID|AZURE_TENANT_ID|KEYVAULT_NAME" || echo "Environment variables verification failed, but continuing..."
          
          # # Verify environment variables in CMP sidecar
          # echo "Verifying environment variables in CMP sidecar..."
          # kubectl exec -n argocd $REPO_POD -c cmp-envsubst -- env | grep -E "AZURE_CLIENT_ID|AZURE_TENANT_ID|KEYVAULT_NAME" || echo "CMP sidecar environment variables verification failed"
          
          # # Check CMP sidecar logs for plugin registration
          # echo "=== CMP Sidecar Logs ==="
          # kubectl logs -n argocd $REPO_POD -c cmp-envsubst || echo "Failed to get CMP sidecar logs"
          # echo "=== End CMP Sidecar Logs ==="
          
          # # Check if plugin config is mounted correctly
          # echo "Checking CMP plugin configuration..."
          # kubectl exec -n argocd $REPO_POD -c cmp-envsubst -- ls -la /home/argocd/cmp-server/config/ || echo "Failed to check plugin config"
          # kubectl exec -n argocd $REPO_POD -c cmp-envsubst -- cat /home/argocd/cmp-server/config/plugin.yaml || echo "Failed to read plugin config"
          
          # # Install envsubst in the CMP sidecar (if container exists)
          # echo "Installing envsubst in CMP sidecar..."
          # if kubectl exec -n argocd $REPO_POD -c cmp-envsubst -- echo "Container ready" 2>/dev/null; then
          #   kubectl exec -n argocd $REPO_POD -c cmp-envsubst -- sh -c "
          #     apk add --no-cache gettext-envsubst 2>/dev/null || 
          #     apt-get update && apt-get install -y gettext-base 2>/dev/null ||
          #     echo 'envsubst may already be available'
          #   " || echo "envsubst installation attempted"
          # else
          #   echo "CMP sidecar container not ready or not found, skipping envsubst installation"
          # fi

          # Wait for external IP
          echo "Waiting for ArgoCD LoadBalancer IP..."
          RETRY_COUNT=0
          MAX_RETRIES=30
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            EXTERNAL_IP=$(kubectl get svc argocd-server -n argocd -o jsonpath="{.status.loadBalancer.ingress[0].ip}" 2>/dev/null || echo "")
            if [[ -n "$EXTERNAL_IP" && "$EXTERNAL_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "ArgoCD LoadBalancer IP obtained: $EXTERNAL_IP"
              break
            fi
            echo "Waiting for LoadBalancer IP... (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
            sleep 10
            RETRY_COUNT=$((RETRY_COUNT + 1))
          done

          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "Failed to get LoadBalancer IP after $MAX_RETRIES attempts"
            kubectl get svc argocd-server -n argocd
            exit 1
          fi
      - name: Deploy Root Application via ArgoCD
        run: |
          # Simply apply the root application manifest
          kubectl apply -f argocd/bootstrap/root-application.yaml

          # Wait for application to be created and auto-synced
          echo "Waiting for root application to be created and automatically synced..."
          sleep 30

      - name: Wait for Applications to Deploy
        run: |
          echo "Waiting for ArgoCD applications to deploy..."
          
          # Wait for applications to be created and synced (simple approach)
          echo "Waiting for applications to be healthy..."
          sleep 60  # Give ArgoCD time to create and sync all applications
          
          # Check that all applications are created
          kubectl get applications -n argocd || echo "Applications are being created..."
          
          echo "ArgoCD Applications deployment initiated!"
          echo "Check ArgoCD UI for detailed status at: http://$(kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].ip}')"
          
          # Final ArgoCD debugging
          echo ""
          echo "=== Final ArgoCD Status Check ==="
          kubectl get pods -n argocd
          echo ""
          kubectl get configmaps -n argocd
          echo ""
          echo "=== ArgoCD ConfigMap Content ==="
          kubectl get configmap argocd-cm -n argocd -o yaml || echo "ERROR: ConfigMap argocd-cm not found"
          echo ""
          echo "=== ArgoCD Server Logs (last 20 lines) ==="
          kubectl logs -n argocd -l app.kubernetes.io/name=argocd-server --tail=20 || true
          echo "=== End Final Status Check ==="
          echo "Username: admin"
          echo "Password: $ARGOCD_PASSWORD"

  terraform-destroy:
    name: "Terraform Destroy"
    if: github.event.inputs.destroy == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Init
        working-directory: ./terraform
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ secrets.TF_STATE_RG }}" \
            -backend-config="storage_account_name=${{ secrets.TF_STATE_SA }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=${{ env.TF_VAR_environment }}.terraform.tfstate"

      - name: Terraform Destroy
        working-directory: ./terraform
        run: terraform destroy -auto-approve