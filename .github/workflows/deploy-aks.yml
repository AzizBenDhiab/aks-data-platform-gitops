# .github/workflows/deploy-aks-data-platform.yml
name: Deploy AKS Data Platform with ArgoCD
on:
  # push:
  #   branches: [main]
  #   paths:
  #     - "terraform/**"
  #     - "k8s/**"
  #     - "argocd/**"
  #     - ".github/workflows/**"
  #     - "manifests/**"
  #     - "values/**"
  # pull_request:
  #   branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - staging
          - prod
      resource_group_name:
        description: "Resource Group Name"
        required: true
        default: "rg-aks-data-dev"
        type: string
      location:
        description: "Azure Region"
        required: true
        default: "West Europe"
        type: string
      cluster_name:
        description: "AKS Cluster Name"
        required: true
        default: "aks-data-dev-test"
        type: string
      kubernetes_version:
        description: "Kubernetes Version"
        required: true
        default: "1.32.5"
        type: string
      system_node_count:
        description: "System Node Count"
        required: true
        default: "2"
        type: string
      workload_identity_namespace:
        description: "Workload Identity Namespace"
        required: true
        default: "default"
        type: string
      workload_identity_service_account:
        description: "Workload Identity Service Account"
        required: true
        default: "workload-identity-sa"
        type: string
      keyvaultname:
        description: "Key Vault Name"
        required: true
        default: "kv-aks-data-dev-95548452"
        type: string
      destroy:
        description: "Destroy infrastructure"
        required: false
        default: false
        type: boolean

# Grant GITHUB_TOKEN write permissions for id-token and contents
permissions:
  id-token: write
  contents: read
  pull-requests: write

env:
  # Remove ARM_CLIENT_SECRET - not needed for OIDC
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  ARM_USE_OIDC: true
  TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
  TF_VAR_resource_group_name: ${{ github.event.inputs.resource_group_name || 'rg-aks-data-dev' }}
  TF_VAR_location: ${{ github.event.inputs.location || 'West Europe' }}
  TF_VAR_cluster_name: ${{ github.event.inputs.cluster_name || 'aks-data-dev-test' }}
  TF_VAR_kubernetes_version: ${{ github.event.inputs.kubernetes_version || '1.32.5' }}
  TF_VAR_system_node_count: ${{ github.event.inputs.system_node_count || '2' }}
  TF_VAR_subscription_id: ${{ github.event.inputs.subscription_id || 'a6de3cd4-15d9-4c7f-87ac-9a4399b01e45' }}
  TF_VAR_workload_identity_namespace: ${{ github.event.inputs.workload_identity_namespace || 'default' }}
  TF_VAR_workload_identity_service_account: ${{ github.event.inputs.workload_identity_service_account || 'workload-identity-sa' }}
  TF_VAR_keyvaultname: ${{ github.event.inputs.keyvaultname || 'kv-aks-data-dev-95548452' }}

jobs:
  terraform:
    name: "Terraform Plan & Apply"
    runs-on: ubuntu-latest

    outputs:
      cluster_name: ${{ steps.tf-output.outputs.cluster_name }}
      resource_group: ${{ steps.tf-output.outputs.resource_group }}
      keyvault_name: ${{ steps.tf-output.outputs.keyvault_name }}
      azure_client_id: ${{ steps.tf-output.outputs.azure_client_id }}
      azure_tenant_id: ${{ steps.tf-output.outputs.azure_tenant_id }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Init
        working-directory: ./terraform
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ secrets.TF_STATE_RG }}" \
            -backend-config="storage_account_name=${{ secrets.TF_STATE_SA }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=${{ env.TF_VAR_environment }}.terraform.tfstate"

      - name: Terraform Validate
        working-directory: ./terraform
        run: terraform validate

      - name: Terraform Plan
        working-directory: ./terraform
        run: |
          terraform plan -out=tfplan
          echo "Plan file created: tfplan"

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main'
        working-directory: ./terraform
        run: |
          echo "Applying terraform plan..."
          ls -la tfplan  # Verify plan file exists
          terraform apply -auto-approve tfplan

      - name: Get Terraform Outputs
        if: github.ref == 'refs/heads/main'
        id: tf-output
        working-directory: ./terraform
        run: |
          echo "cluster_name=$(terraform output -raw cluster_name)" >> $GITHUB_OUTPUT
          echo "resource_group=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
          echo "keyvault_name=$(terraform output -raw keyvault_name)" >> $GITHUB_OUTPUT
          echo "azure_client_id=$(terraform output -raw azure_client_id)" >> $GITHUB_OUTPUT
          echo "azure_tenant_id=$(terraform output -raw azure_tenant_id)" >> $GITHUB_OUTPUT

  generate-keyvault-secrets:
    name: "Generate Key Vault Secrets"
    runs-on: ubuntu-latest
    needs: [terraform]
    if: success()

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Generate and Store Secrets in Key Vault
        run: |
          # Get Key Vault name from terraform output
          KEYVAULT_NAME="${{ needs.terraform.outputs.keyvault_name }}"

          echo "Using Key Vault: $KEYVAULT_NAME"

          # Generate secure passwords for all applications
          SUPERSET_SECRET_KEY=$(openssl rand -base64 48 | tr -d "=+/" | cut -c1-48)
          SUPERSET_POSTGRES_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          SUPERSET_ADMIN_PASSWORD=$(openssl rand -base64 16 | tr -d "=+/" | cut -c1-16)
          NIFI_SENSITIVE_KEY=$(openssl rand -base64 24 | tr -d "=+/" | cut -c1-24)
          NIFI_KEYSTORE_PASSWORD=$(openssl rand -base64 24 | tr -d "=+/" | cut -c1-24)
          NIFI_TRUSTSTORE_PASSWORD=$(openssl rand -base64 24 | tr -d "=+/" | cut -c1-24)
          NIFI_ADMIN_PASSWORD=$(openssl rand -base64 16 | tr -d "=+/" | cut -c1-16)
          KOBO_REDIS_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          KOBO_ADMIN_PASSWORD=$(openssl rand -base64 16 | tr -d "=+/" | cut -c1-16)
          KOBO_DJANGO_SECRET=$(openssl rand -base64 48 | tr -d "=+/" | cut -c1-48)
          KOBO_POSTGRES_ADMIN_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          KOBO_POSTGRES_USER_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          KOBO_MONGO_ROOT_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          KOBO_MONGO_USER_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          GRAFANA_ADMIN_PASSWORD=$(openssl rand -base64 16 | tr -d "=+/" | cut -c1-16)
          ALERTMANAGER_SECRET=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          PROMETHEUS_SECRET=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)

          # Add monitoring secrets to Key Vault
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "grafana-admin-user" --value "admin"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "grafana-admin-password" --value "$GRAFANA_ADMIN_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "alertmanager-secret" --value "$ALERTMANAGER_SECRET"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "prometheus-secret" --value "$PROMETHEUS_SECRET"

          # Add Joget secrets to Key Vault
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "joget-database" --value "joget"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "joget-username" --value "joget_user"
          # Add Superset secrets
          echo "Adding Superset secrets..."
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "superset-secret-key" --value "$SUPERSET_SECRET_KEY"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "superset-postgres-password" --value "$SUPERSET_POSTGRES_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "superset-admin-password" --value "$SUPERSET_ADMIN_PASSWORD"

          # Add NiFi secrets
          echo "Adding NiFi secrets..."
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "nifi-sensitive-key" --value "$NIFI_SENSITIVE_KEY"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "nifi-keystore-password" --value "$NIFI_KEYSTORE_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "nifi-truststore-password" --value "$NIFI_TRUSTSTORE_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "nifi-admin-password" --value "$NIFI_ADMIN_PASSWORD"

          # Add KoboToolbox secrets
          echo "Adding KoboToolbox secrets..."
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-redis-password" --value "$KOBO_REDIS_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-admin-password" --value "$KOBO_ADMIN_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-django-secret" --value "$KOBO_DJANGO_SECRET"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-postgres-admin-password" --value "$KOBO_POSTGRES_ADMIN_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-postgres-user-password" --value "$KOBO_POSTGRES_USER_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-mongo-root-password" --value "$KOBO_MONGO_ROOT_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-mongo-user-password" --value "$KOBO_MONGO_USER_PASSWORD"

          echo "All secrets have been stored in Key Vault: $KEYVAULT_NAME"

  setup-argocd:
    name: "Setup ArgoCD"
    runs-on: ubuntu-latest
    needs: [terraform, generate-keyvault-secrets]
    if: success()

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.terraform.outputs.resource_group }} \
            --name ${{ needs.terraform.outputs.cluster_name }} \
            --overwrite-existing

      - name: Install ArgoCD
        run: |
          # Create ArgoCD namespace
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -

          # Install ArgoCD
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

          # Wait for ArgoCD to be ready
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-server -n argocd

          # Configure environment variables for ArgoCD server to enable variable substitution
          echo "Configuring ArgoCD server with Azure environment variables..."
          AZURE_CLIENT_ID="${{ needs.terraform.outputs.azure_client_id }}"
          AZURE_TENANT_ID="${{ needs.terraform.outputs.azure_tenant_id }}"
          KEYVAULT_NAME="${{ needs.terraform.outputs.keyvault_name }}"
          
          kubectl patch deployment argocd-server -n argocd -p "{\"spec\":{\"template\":{\"spec\":{\"containers\":[{\"name\":\"argocd-server\",\"env\":[{\"name\":\"AZURE_CLIENT_ID\",\"value\":\"$AZURE_CLIENT_ID\"},{\"name\":\"AZURE_TENANT_ID\",\"value\":\"$AZURE_TENANT_ID\"},{\"name\":\"KEYVAULT_NAME\",\"value\":\"$KEYVAULT_NAME\"}]}]}}}}"
          
          kubectl patch deployment argocd-repo-server -n argocd -p "{\"spec\":{\"template\":{\"spec\":{\"containers\":[{\"name\":\"argocd-repo-server\",\"env\":[{\"name\":\"AZURE_CLIENT_ID\",\"value\":\"$AZURE_CLIENT_ID\"},{\"name\":\"AZURE_TENANT_ID\",\"value\":\"$AZURE_TENANT_ID\"},{\"name\":\"KEYVAULT_NAME\",\"value\":\"$KEYVAULT_NAME\"}]}]}}}}"
          
          # Wait for deployments to restart with new environment variables
          kubectl rollout restart deployment/argocd-server -n argocd
          kubectl rollout restart deployment/argocd-repo-server -n argocd
          kubectl rollout status deployment/argocd-server -n argocd --timeout=300s
          kubectl rollout status deployment/argocd-repo-server -n argocd --timeout=300s

      - name: Configure ArgoCD
        run: |
          # Get ArgoCD admin password
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "ARGOCD_PASSWORD=$ARGOCD_PASSWORD" >> $GITHUB_ENV

          # Create ArgoCD service LoadBalancer
          kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'

          # Configure ArgoCD with Azure environment variables for substitution
          echo "Configuring ArgoCD with Azure environment variables..."
          
          # Get Azure parameters from terraform outputs
          AZURE_CLIENT_ID="${{ needs.terraform.outputs.azure_client_id }}"
          AZURE_TENANT_ID="${{ needs.terraform.outputs.azure_tenant_id }}"
          KEYVAULT_NAME="${{ needs.terraform.outputs.keyvault_name }}"
          
          # Create a ConfigMap with Azure environment variables
          kubectl create configmap argocd-env -n argocd \
            --from-literal=AZURE_CLIENT_ID="$AZURE_CLIENT_ID" \
            --from-literal=AZURE_TENANT_ID="$AZURE_TENANT_ID" \
            --from-literal=KEYVAULT_NAME="$KEYVAULT_NAME" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Enable environment variable expansion in ArgoCD ConfigMap
          kubectl patch configmap argocd-cm -n argocd --patch '
          data:
            application.instanceLabelKey: argocd.argoproj.io/instance
            server.rbac.log.enforce.enable: "false"
            exec.enabled: "false"
            server.enable.proxy.extension: "false"
            reposerver.enable.git.submodule: "true"
            # Enable environment variable substitution
            kustomize.buildOptions: "--enable-alpha-plugins --load_restrictor none"
          ' || echo "ConfigMap argocd-cm might not exist yet, continuing..."
          
          # Patch ArgoCD repo-server deployment to use the ConfigMap
          kubectl patch deployment argocd-repo-server -n argocd --type='merge' -p='
          {
            "spec": {
              "template": {
                "spec": {
                  "containers": [
                    {
                      "name": "repo-server",
                      "envFrom": [
                        {
                          "configMapRef": {
                            "name": "argocd-env"
                          }
                        }
                      ]
                    }
                  ]
                }
              }
            }
          }'
          
          # Wait for repo-server deployment to restart
          kubectl rollout restart deployment/argocd-repo-server -n argocd
          kubectl rollout status deployment/argocd-repo-server -n argocd --timeout=300s

          # Wait for external IP (with timeout and better error handling)
          echo "Waiting for ArgoCD LoadBalancer IP..."
          RETRY_COUNT=0
          MAX_RETRIES=30
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            EXTERNAL_IP=$(kubectl get svc argocd-server -n argocd -o jsonpath="{.status.loadBalancer.ingress[0].ip}" 2>/dev/null || echo "")
            if [[ -n "$EXTERNAL_IP" && "$EXTERNAL_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "ArgoCD LoadBalancer IP obtained: $EXTERNAL_IP"
              break
            fi
            echo "Waiting for LoadBalancer IP... (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
            sleep 10
            RETRY_COUNT=$((RETRY_COUNT + 1))
          done
          
          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "Failed to get LoadBalancer IP after $MAX_RETRIES attempts"
            kubectl get svc argocd-server -n argocd
            exit 1
          fi

      - name: Deploy Root Application via ArgoCD
        run: |
          # Get ArgoCD server external IP
          ARGOCD_SERVER=$(kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "ArgoCD Server IP: $ARGOCD_SERVER"

          # Install ArgoCD CLI if not already available
          echo "Checking for ArgoCD CLI..."
          
          if command -v argocd &> /dev/null; then
            echo "ArgoCD CLI already installed"
            argocd version --client
          else
            echo "Installing ArgoCD CLI..."
            
            # Download to /tmp directory
            curl -sSL -o /tmp/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
            
            # Verify download was successful
            if [ ! -f /tmp/argocd ]; then
              echo "Failed to download ArgoCD CLI"
              exit 1
            fi
            
            # Make executable and move to /usr/local/bin
            chmod +x /tmp/argocd
            sudo mv /tmp/argocd /usr/local/bin/argocd
            
            # Verify installation
            argocd version --client
            echo "ArgoCD CLI installed successfully"
          fi
          # Wait for ArgoCD API to be ready
          sleep 30

          # Login to ArgoCD
          argocd login $ARGOCD_SERVER --username admin --password $ARGOCD_PASSWORD --insecure

          # Apply the root application with environment variable substitution enabled
          kubectl apply -f - <<EOF
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: root-app
            namespace: argocd
          spec:
            project: default
            source:
              repoURL: https://github.com/${{ github.repository }}
              targetRevision: HEAD
              path: argocd/apps
            destination:
              server: https://kubernetes.default.svc
              namespace: argocd
            syncPolicy:
              automated:
                prune: true
                selfHeal: true
          EOF

          # Wait for application to be created and auto-synced
          echo "Waiting for root application to be created and automatically synced..."
          sleep 30
          
          # Check application status and wait for auto-sync to complete
          MAX_WAIT_TIME=300  # 5 minutes
          WAIT_INTERVAL=15   # Check every 15 seconds
          ELAPSED_TIME=0
          
          while [ $ELAPSED_TIME -lt $MAX_WAIT_TIME ]; do
            APP_STATUS=$(argocd app get root-app -o json | jq -r '.status.sync.status' 2>/dev/null || echo "Unknown")
            APP_HEALTH=$(argocd app get root-app -o json | jq -r '.status.health.status' 2>/dev/null || echo "Unknown")
            
            echo "Root app - Sync: $APP_STATUS, Health: $APP_HEALTH (waited ${ELAPSED_TIME}s)"
            
            if [ "$APP_STATUS" = "Synced" ]; then
              echo "Root application successfully auto-synced!"
              break
            fi
            
            sleep $WAIT_INTERVAL
            ELAPSED_TIME=$((ELAPSED_TIME + WAIT_INTERVAL))
          done
          
          if [ $ELAPSED_TIME -ge $MAX_WAIT_TIME ]; then
            echo "Warning: Root application did not sync within $MAX_WAIT_TIME seconds"
            echo "Current status:"
            argocd app get root-app || true
            echo "Continuing with deployment..."
          fi

          echo "ArgoCD setup complete!"
          echo "Access ArgoCD at: http://$ARGOCD_SERVER"
          echo "Username: admin"
          echo "Password: $ARGOCD_PASSWORD"

      - name: Wait for Applications to Deploy
        run: |
          echo "Waiting for ArgoCD applications to deploy..."
          
          # Get ArgoCD server external IP
          ARGOCD_SERVER=$(kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          
          # Login to ArgoCD
          argocd login $ARGOCD_SERVER --username admin --password $ARGOCD_PASSWORD --insecure
          
          # Wait for all applications to be synced and healthy
          argocd app list
          
          # Wait for specific applications to be healthy (using correct app names)
          echo "Waiting for applications to be healthy..."
          argocd app wait apache-superset --timeout 600 || echo "Superset app deployment completed"
          argocd app wait nifi-prod --timeout 600 || echo "NiFi app deployment completed" 
          argocd app wait kobotoolbox --timeout 600 || echo "KoboToolbox app deployment completed"
          argocd app wait postgresql --timeout 600 || echo "PostgreSQL app deployment completed"
          argocd app wait monitoring-stack --timeout 600 || echo "Monitoring app deployment completed"
          argocd app wait joget --timeout 600 || echo "Joget app deployment completed"
          
          echo "All applications deployed successfully!"

  terraform-destroy:
    name: "Terraform Destroy"
    if: github.event.inputs.destroy == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Init
        working-directory: ./terraform
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ secrets.TF_STATE_RG }}" \
            -backend-config="storage_account_name=${{ secrets.TF_STATE_SA }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=${{ env.TF_VAR_environment }}.terraform.tfstate"

      - name: Terraform Destroy
        working-directory: ./terraform
        run: terraform destroy -auto-approve