# .github/workflows/deploy-aks-data-platform.yml
name: Deploy AKS Data Platform with ArgoCD
on:
  # push:
  #   branches: [main]
  #   paths:
  #     - "terraform/**"
  #     - "k8s/**"
  #     - "argocd/**"
  #     - ".github/workflows/**"
  #     - "manifests/**"
  #     - "values/**"
  # pull_request:
  #   branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - staging
          - prod
      resource_group_name:
        description: "Resource Group Name"
        required: true
        default: "rg-aks-data-dev"
        type: string
      location:
        description: "Azure Region"
        required: true
        default: "West Europe"
        type: string
      cluster_name:
        description: "AKS Cluster Name"
        required: true
        default: "aks-data-dev-test"
        type: string
      kubernetes_version:
        description: "Kubernetes Version"
        required: true
        default: "1.32.5"
        type: string
      system_node_count:
        description: "System Node Count"
        required: true
        default: "2"
        type: string
      workload_identity_namespace:
        description: "Workload Identity Namespace"
        required: true
        default: "default"
        type: string
      workload_identity_service_account:
        description: "Workload Identity Service Account"
        required: true
        default: "workload-identity-sa"
        type: string
      keyvaultname:
        description: "Key Vault Name"
        required: true
        default: "kv-aks-data-dev-95548452"
        type: string
      destroy:
        description: "Destroy infrastructure"
        required: false
        default: false
        type: boolean

# Grant GITHUB_TOKEN write permissions for id-token and contents
permissions:
  id-token: write
  contents: read
  pull-requests: write

env:
  # Remove ARM_CLIENT_SECRET - not needed for OIDC
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  ARM_USE_OIDC: true
  TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
  TF_VAR_resource_group_name: ${{ github.event.inputs.resource_group_name || 'rg-aks-data-dev' }}
  TF_VAR_location: ${{ github.event.inputs.location || 'West Europe' }}
  TF_VAR_cluster_name: ${{ github.event.inputs.cluster_name || 'aks-data-dev-test' }}
  TF_VAR_kubernetes_version: ${{ github.event.inputs.kubernetes_version || '1.32.5' }}
  TF_VAR_system_node_count: ${{ github.event.inputs.system_node_count || '2' }}
  TF_VAR_subscription_id: ${{ github.event.inputs.subscription_id || 'a6de3cd4-15d9-4c7f-87ac-9a4399b01e45' }}
  TF_VAR_workload_identity_namespace: ${{ github.event.inputs.workload_identity_namespace || 'default' }}
  TF_VAR_workload_identity_service_account: ${{ github.event.inputs.workload_identity_service_account || 'workload-identity-sa' }}
  TF_VAR_keyvaultname: ${{ github.event.inputs.keyvaultname || 'kv-aks-data-dev-95548452' }}

jobs:
  terraform:
    name: "Terraform Plan & Apply"
    runs-on: ubuntu-latest

    outputs:
      cluster_name: ${{ steps.tf-output.outputs.cluster_name }}
      resource_group: ${{ steps.tf-output.outputs.resource_group }}
      keyvault_name: ${{ steps.tf-output.outputs.keyvault_name }}
      azure_client_id: ${{ steps.tf-output.outputs.azure_client_id }}
      azure_tenant_id: ${{ steps.tf-output.outputs.azure_tenant_id }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Init
        working-directory: ./terraform
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ secrets.TF_STATE_RG }}" \
            -backend-config="storage_account_name=${{ secrets.TF_STATE_SA }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=${{ env.TF_VAR_environment }}.terraform.tfstate"

      - name: Terraform Validate
        working-directory: ./terraform
        run: terraform validate

      - name: Terraform Plan
        working-directory: ./terraform
        run: |
          terraform plan -out=tfplan
          echo "Plan file created: tfplan"

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main'
        working-directory: ./terraform
        run: |
          echo "Applying terraform plan..."
          ls -la tfplan  # Verify plan file exists
          terraform apply -auto-approve tfplan

      - name: Get Terraform Outputs
        if: github.ref == 'refs/heads/main'
        id: tf-output
        working-directory: ./terraform
        run: |
          echo "cluster_name=$(terraform output -raw cluster_name)" >> $GITHUB_OUTPUT
          echo "resource_group=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
          echo "keyvault_name=$(terraform output -raw keyvault_name)" >> $GITHUB_OUTPUT
          echo "azure_client_id=$(terraform output -raw azure_client_id)" >> $GITHUB_OUTPUT
          echo "azure_tenant_id=$(terraform output -raw azure_tenant_id)" >> $GITHUB_OUTPUT

  generate-keyvault-secrets:
    name: "Generate Key Vault Secrets"
    runs-on: ubuntu-latest
    needs: [terraform]
    if: success()

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Generate and Store Secrets in Key Vault
        run: |
          # Get Key Vault name from terraform output
          KEYVAULT_NAME="${{ needs.terraform.outputs.keyvault_name }}"

          echo "Using Key Vault: $KEYVAULT_NAME"

          # Generate secure passwords for all applications
          SUPERSET_SECRET_KEY=$(openssl rand -base64 48 | tr -d "=+/" | cut -c1-48)
          SUPERSET_POSTGRES_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          SUPERSET_ADMIN_PASSWORD=$(openssl rand -base64 16 | tr -d "=+/" | cut -c1-16)
          NIFI_SENSITIVE_KEY=$(openssl rand -base64 24 | tr -d "=+/" | cut -c1-24)
          NIFI_KEYSTORE_PASSWORD=$(openssl rand -base64 24 | tr -d "=+/" | cut -c1-24)
          NIFI_TRUSTSTORE_PASSWORD=$(openssl rand -base64 24 | tr -d "=+/" | cut -c1-24)
          NIFI_ADMIN_PASSWORD=$(openssl rand -base64 16 | tr -d "=+/" | cut -c1-16)
          KOBO_REDIS_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          KOBO_ADMIN_PASSWORD=$(openssl rand -base64 16 | tr -d "=+/" | cut -c1-16)
          KOBO_DJANGO_SECRET=$(openssl rand -base64 48 | tr -d "=+/" | cut -c1-48)
          KOBO_POSTGRES_ADMIN_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          KOBO_POSTGRES_USER_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          KOBO_MONGO_ROOT_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          KOBO_MONGO_USER_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          GRAFANA_ADMIN_PASSWORD=$(openssl rand -base64 16 | tr -d "=+/" | cut -c1-16)
          ALERTMANAGER_SECRET=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          PROMETHEUS_SECRET=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)

          # Add monitoring secrets to Key Vault
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "grafana-admin-user" --value "admin"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "grafana-admin-password" --value "$GRAFANA_ADMIN_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "alertmanager-secret" --value "$ALERTMANAGER_SECRET"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "prometheus-secret" --value "$PROMETHEUS_SECRET"

          # Add Joget secrets to Key Vault
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "joget-database" --value "joget"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "joget-username" --value "joget_user"
          # Add Superset secrets
          echo "Adding Superset secrets..."
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "superset-secret-key" --value "$SUPERSET_SECRET_KEY"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "superset-postgres-password" --value "$SUPERSET_POSTGRES_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "superset-admin-password" --value "$SUPERSET_ADMIN_PASSWORD"

          # Add NiFi secrets
          echo "Adding NiFi secrets..."
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "nifi-sensitive-key" --value "$NIFI_SENSITIVE_KEY"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "nifi-keystore-password" --value "$NIFI_KEYSTORE_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "nifi-truststore-password" --value "$NIFI_TRUSTSTORE_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "nifi-admin-password" --value "$NIFI_ADMIN_PASSWORD"

          # Add KoboToolbox secrets
          echo "Adding KoboToolbox secrets..."
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-redis-password" --value "$KOBO_REDIS_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-admin-password" --value "$KOBO_ADMIN_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-django-secret" --value "$KOBO_DJANGO_SECRET"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-postgres-admin-password" --value "$KOBO_POSTGRES_ADMIN_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-postgres-user-password" --value "$KOBO_POSTGRES_USER_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-mongo-root-password" --value "$KOBO_MONGO_ROOT_PASSWORD"
          az keyvault secret set --vault-name $KEYVAULT_NAME --name "kobo-mongo-user-password" --value "$KOBO_MONGO_USER_PASSWORD"

          echo "All secrets have been stored in Key Vault: $KEYVAULT_NAME"

  setup-argocd:
    name: "Setup ArgoCD"
    runs-on: ubuntu-latest
    needs: [terraform, generate-keyvault-secrets]
    if: success()

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.terraform.outputs.resource_group }} \
            --name ${{ needs.terraform.outputs.cluster_name }} \
            --overwrite-existing

      - name: Install ArgoCD
        run: |
          # Create ArgoCD namespace
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -

          # Install ArgoCD
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

          # Wait for ArgoCD to be ready
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-server -n argocd

      - name: Configure ArgoCD
        run: |
          # Get ArgoCD admin password
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "ARGOCD_PASSWORD=$ARGOCD_PASSWORD" >> $GITHUB_ENV

          # Create ArgoCD service LoadBalancer
          kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'

          # Get Azure parameters from terraform outputs for environment variable substitution
          AZURE_CLIENT_ID="${{ needs.terraform.outputs.azure_client_id }}"
          AZURE_TENANT_ID="${{ needs.terraform.outputs.azure_tenant_id }}"
          KEYVAULT_NAME="${{ needs.terraform.outputs.keyvault_name }}"

          # Create a ConfigMap with Azure environment variables for ArgoCD to use
          kubectl create configmap argocd-env -n argocd \
            --from-literal=AZURE_CLIENT_ID="$AZURE_CLIENT_ID" \
            --from-literal=AZURE_TENANT_ID="$AZURE_TENANT_ID" \
            --from-literal=KEYVAULT_NAME="$KEYVAULT_NAME" \
            --dry-run=client -o yaml | kubectl apply -f -

          # Configure CMP plugin for envsubst to process all YAML files
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: cmp-plugin
            namespace: argocd
          data:
            plugin.yaml: |
              apiVersion: argoproj.io/v1alpha1
              kind: ConfigManagementPlugin
              metadata:
                name: envsubst
              spec:
                generate:
                  command: ["sh", "-c"]
                  args: ["find \$ARGOCD_APP_SOURCE_PATH -name '*.yaml' -exec envsubst < {} \\; -exec echo '---' \\;"]
          EOF

          # Enable CMP plugin in ArgoCD
          kubectl patch configmap argocd-cm -n argocd --type merge -p='
          {
            "data": {
              "configManagementPlugins": |
                - name: envsubst
                  generate:
                    command: ["sh", "-c"]
                    args: ["find \$ARGOCD_APP_SOURCE_PATH -name \"*.yaml\" -exec envsubst < {} \\; -exec echo \"---\" \\;"]
            }
          }'

          # Inject environment variables into ArgoCD repo-server
          kubectl set env deployment/argocd-repo-server -n argocd --from=configmap/argocd-env

          # Ensure envsubst is available in the argocd-repo-server container (Ubuntu-based image)
          kubectl patch deployment argocd-repo-server -n argocd --type=json -p='[
            {
              "op": "add",
              "path": "/spec/template/spec/containers/0/command",
              "value": ["/usr/local/bin/argocd", "repo-server"]
            },
            {
              "op": "add",
              "path": "/spec/template/spec/containers/0/image",
              "value": "argoproj/argocd:v2.12.4"
            },
            {
              "op": "add",
              "path": "/spec/template/spec/containers/0/volumeMounts/-",
              "value": {
                "name": "cmp-plugin",
                "mountPath": "/home/argocd/cmp-server/plugins"
              }
            },
            {
              "op": "add",
              "path": "/spec/template/spec/volumes/-",
              "value": {
                "name": "cmp-plugin",
                "configMap": {
                  "name": "cmp-plugin"
                }
              }
            }
          ]'

          # Install envsubst in argocd-repo-server (Ubuntu-based image)
          kubectl exec -n argocd deployment/argocd-repo-server -- sh -c "command -v envsubst || (apt-get update && apt-get install -y gettext-base)" || echo "Failed to install envsubst, but continuing..."

          # Force restart of repo-server to ensure environment variables and plugin are loaded
          kubectl rollout restart deployment/argocd-repo-server -n argocd

          # Wait for repo-server deployment to be ready
          kubectl rollout status deployment/argocd-repo-server -n argocd --timeout=300s

          # Verify environment variables are properly injected
          echo "Verifying environment variables in repo-server..."
          kubectl exec -n argocd deployment/argocd-repo-server -- env | grep -E "AZURE_CLIENT_ID|AZURE_TENANT_ID|KEYVAULT_NAME" || echo "Environment variables verification failed, but continuing..."

          # Wait for external IP
          echo "Waiting for ArgoCD LoadBalancer IP..."
          RETRY_COUNT=0
          MAX_RETRIES=30
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            EXTERNAL_IP=$(kubectl get svc argocd-server -n argocd -o jsonpath="{.status.loadBalancer.ingress[0].ip}" 2>/dev/null || echo "")
            if [[ -n "$EXTERNAL_IP" && "$EXTERNAL_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "ArgoCD LoadBalancer IP obtained: $EXTERNAL_IP"
              break
            fi
            echo "Waiting for LoadBalancer IP... (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
            sleep 10
            RETRY_COUNT=$((RETRY_COUNT + 1))
          done

          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "Failed to get LoadBalancer IP after $MAX_RETRIES attempts"
            kubectl get svc argocd-server -n argocd
            exit 1
          fi
      - name: Deploy Root Application via ArgoCD
        run: |
          # Simply apply the root application manifest
          kubectl apply -f argocd/bootstrap/root-application.yaml

          # Wait for application to be created and auto-synced
          echo "Waiting for root application to be created and automatically synced..."
          sleep 30

      - name: Wait for Applications to Deploy
        run: |
          echo "Waiting for ArgoCD applications to deploy..."
          
          # Wait for applications to be created and synced (simple approach)
          echo "Waiting for applications to be healthy..."
          sleep 60  # Give ArgoCD time to create and sync all applications
          
          # Check that all applications are created
          kubectl get applications -n argocd || echo "Applications are being created..."
          
          echo "ArgoCD Applications deployment initiated!"
          echo "Check ArgoCD UI for detailed status at: http://$(kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].ip}')"
          echo "Username: admin"
          echo "Password: $ARGOCD_PASSWORD"

  terraform-destroy:
    name: "Terraform Destroy"
    if: github.event.inputs.destroy == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Init
        working-directory: ./terraform
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ secrets.TF_STATE_RG }}" \
            -backend-config="storage_account_name=${{ secrets.TF_STATE_SA }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=${{ env.TF_VAR_environment }}.terraform.tfstate"

      - name: Terraform Destroy
        working-directory: ./terraform
        run: terraform destroy -auto-approve